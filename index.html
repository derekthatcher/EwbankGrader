<!DOCTYPE html>
<html>

<head>
  <title>Ewbank Grader</title>
  <meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Figure out how hard your rad link up is by breaking it down into parts.">
  <meta name="keywords"
    content="Ewbank, climbing grades, sport climbing, grade converter, climbing scale, Australia, New Zealand, climbing tool">
  <meta name="author" content="Derek Thatcher @ castlehillbasin.co.nz">
  <meta property="og:image" content="chb.png" />
  <meta property="og:image:secure_url" content="chb.png" />
  <meta name="MobileOptimized" content="width" />
  <meta name="HandheldFriendly" content="true" />
  <link rel="icon" type="image/png" href="favicon.png" sizes="32x32">

  <style>
    @import url('https://fonts.googleapis.com/css?family=Barlow|Barlow+Condensed|Barlow+Semi+Condensed&display=swap');

    body {
      text-align: left;
      margin: 0;
      font-family: 'Barlow', sans-serif;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      text-transform: uppercase;
      font-family: 'Barlow Semi Condensed', sans-serif;
      line-height: 1.8em;
      letter-spacing: 0.03em;
    }

    h1 {
      text-align: center;
      margin-top: 5vh;
      ;
    }

    h3 {
      margin: 0;
      line-height: normal;
    }

    .container {
      min-height: 80vh;
      display: flex;
      flex-wrap: wrap;
      /* Important for mobile responsiveness */
    }

    .column {
      flex: 1;
      /* Equal width columns by default */
      padding: 50px;
      box-sizing: border-box;
      /* Include padding in width calculations */
    }

    .error {
      border: 2px solid red;
      background-color: #ecafaf;
    }

    .noresult {
      opacity: 0.3;
    }

    ul {
      padding-left: 0;
    }

    ul li {
      list-style: none;
      margin-bottom: 5px;
    }

    ul button {
      border-radius: 0;
      font-size: 1em;
      padding: 1 5px;
      background: none;
      border-width: 1px;
      margin: 4px;
    }

    ul button:hover {
      background-color: #eaffd9;
    }

    ul button.delete:hover {
      background-color: #ffd9d9;
    }

    #input {
      line-height: 1.5em;
      font-size: 1em;
      width: 100%;
      box-sizing: border-box;
    }

    #result {
      margin-top: 20px;
      margin-bottom: 20px;
      ;
    }

    #output span {
      color: #666;
      font-size: 0.7em;
      font-style: italic;
    }

    #calibration {
      padding: 0 18px;
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease-out;
      background-color: #f1f1f1;
    }

    #calibration.show {
      max-height: 800px;
      /* Or any large number */
    }

    .collapsible {
      margin-top: 20px;
      background-color: #ebe9e9;
    }

    .collapsible h4 {
      margin-bottom: 0;
      margin-left: 5px;
    }

    footer {
      background-color: black;
      text-align: center;
      width: 100vw;
    }

    footer img {
      width: 200px;
      margin: 30px auto 100px auto;
    }

    /* Mobile Styles (adjust breakpoint as needed) */
    @media (max-width: 1000px) {
      .column {
        flex: 1 0 100%;
        padding: 10px;
      }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>

<body>
  <h1 id="title">Ewbank Grader</h1>
  <div class="container">
    <div class="column">
      <div id="text">Grade sport climbs by breaking them down into small sections. Enter strings like "25 N 25 G V6",
        Ewbank or V-grades seperated by letters for the type of rest.
        <br /> [ N = no rest, B = bad rest, M = medium rest, G = good rest ].
      </div>
      <input type="text" id="input" name="input"><br><button id="shareURL">Share</button><br>
      <div id="result">
        <h3>Grade: <span id="output"></span></h3>
        <canvas id="gradeGraph"></canvas>
      </div>
      <button id="save">Save to local storage</button><br>
      <div class="collapsible">
        <h4>Calibration</h4>
      </div>
      <div id="calibration">
        <div>To calibrate this to a particular crag or style think about two climbs of the same grade stacked on top of
          each other. Consider what the combined
          grade would be with no rest (N) and also with a good rest (G).<br />
          Set N to be the no rest increase in grade, and G to be the good rest increase.<br />
          For example, by default N is 2.5, which means if you stack two 25s with no rest you get a 27.5 (a 27/28).
          A good rest would add 1.75 grades and result in a soft 27.<br />This accepts decimal grades, X-1.8 to X.2
          being on
          the grade, X.2 to X.4 = X.hard, X.4 to X.6 = X-1/X (slash grade), X.6 to X.8 = X+1.soft.
        </div>
        <br />
        <input type="range" id="sliderN" min="1" max="4" step="0.05" value="2.5">
        <div id="sliderOutputN">No rest change: 2.5</div>
        <input type="range" id="sliderG" min="0" max="4" step="0.05" value="1.75">
        <div id="sliderOutputG">Good rest change: 1.75</div>
        <br />
        <canvas id="myChart"></canvas>
      </div>
    </div>
    <div class="column">
      <h3>Benchmarks and saved climbs</h3>
      <ul id="climbList"></ul>
    </div>
  </div>
  <footer>
    <img src="chb-logo-white.svg" alt="chb logo">
  </footer>
  <script>
    /**************************************
      Constants and Variables
    **************************************/
    const sliderN = document.getElementById("sliderN");
    const sliderG = document.getElementById("sliderG");
    const climbString = document.getElementById("input");
    const sliderOutputN = document.getElementById("sliderOutputN");
    const sliderOutputG = document.getElementById("sliderOutputG");
    const collapsible = document.querySelector(".collapsible");
    const content = document.querySelector("#calibration");
    const output = document.getElementById('output');
    const climbListUL = document.getElementById("climbList");
    const gradeUpperBounds = { "soft": 0.8, "middle": 0.2, "hard": 0.4, "slash": 0.6 };
    const ctx = document.getElementById('myChart').getContext('2d');
    let ewbankClimbList = []; //load from local storage
    let graph = null;
    const CANVAS_HEIGHT = 150; // Fixed height
    const BAR_HEIGHT = 40;
    const BAR_Y = 55;
    const TOTAL_SPAN = 1.4;

    /**************************************
      Event Listeners
    **************************************/
    climbString.addEventListener("input", function () {
      gradeIt();
    });

    document.querySelector("#save").addEventListener("click", function () {
      // save current state to local storage json object.
      ewbankClimbList.push({ 'climbString': climbString.value, 'sliderN': sliderN.value, 'sliderG': sliderG.value, 'grade': solve(formatGradeString(climbString.value)) });
      localStorage.setItem("ewbankClimbList", JSON.stringify(ewbankClimbList));
      updateClimbList()
      console.log(ewbankClimbList);
    });

    sliderN.addEventListener("input", function () {
      sliderOutputN.textContent = "No rest change: " + sliderN.value;
      gradeIt();
      graphIt();
    });

    sliderG.addEventListener("input", function () {
      sliderOutputG.textContent = "Good rest change: " + sliderG.value;
      gradeIt();
      graphIt();
    });

    collapsible.addEventListener("click", function () {
      this.classList.toggle("active");
      if (content.classList.contains('show')) {
        content.classList.remove("show");
      }
      else {
        content.classList.add("show");
      }

    });

    document.querySelector("#shareURL").addEventListener("click", function () {
      // create encoded url and copy to clipboard
      const encodedClimbString = btoa(JSON.stringify(climbString.value)); // Base64 encode
      const baseUrl = window.location.href.split('?')[0];
      let shortenedUrl = `${baseUrl}?data=${encodedClimbString}`;
      //checkif sliders have changed
      if (sliderN.valueAsNumber != 2.5 || sliderG.valueAsNumber != 1.75) {
        shortenedUrl += `&sliderN=${sliderN.valueAsNumber}&sliderG=${sliderG.valueAsNumber}`;
      }
      // copy to clipboard
      if (navigator.clipboard) {
        navigator.clipboard.writeText(shortenedUrl)
          .then(() => {
            alert("URL copied to clipboard!");
          })
          .catch(err => {
            console.error('Could not copy text: ', err);
            alert("Failed to copy URL.");
          });
      } else {
        // Fallback for older browsers (less reliable)
        const textArea = document.createElement("textarea");
        textArea.value = shortenedUrl;
        document.body.appendChild(textArea);
        textArea.select();
        try {
          document.execCommand('copy');
          alert("URL copied to clipboard!");
        } catch (err) {
          console.error('Could not copy text: ', err);
          alert("Failed to copy URL.");
        }
        document.body.removeChild(textArea);
      }
    });

    /**************************************
      Functions
    **************************************/

    function gradeIt() {
      // deal with different data strings
      // 25n25g28 etc v5bv5 
      // need to recursively solve - need lots of error checking.
      let input = formatGradeString(climbString.value);
      if (input != "Error") {
        result = solve(input);
        climbString.classList.remove("error");
        output.classList.remove("noresult");
        output.innerHTML = translateGradeValue(result) + " <span>" + Math.round(result * 100) / 100 + "</span>";
      } else {
        climbString.classList.add("error");
        output.classList.add("noresult");
      }
    };

    function graphIt() {
      // Check if a chart instance already exists.
      if (graph) {
        // Destroy the existing chart instance.
        graph.destroy();
      }
      let quadraticData = [[], [], [], []];
      let restOptions = ["N", "B", "M", "G"];
      for (i = 0; i < 4; i++) {
        restValue = getRestValue(restOptions[i]);
        let a = ((4 - restValue) / 64)
        let b = (restValue / 8) - 8 * a;
        let c = 0;
        for (let x = -8; x <= 8; x += 1) {
          quadraticData[i].push({ x: x, y: a * (x + 8) * (x + 8) + b * (x + 8) + c });
        }
      }
      graph = new Chart(ctx, {
        type: 'line',
        data: {
          datasets: [{
            label: 'No Rest',
            data: quadraticData[0],
            borderColor: '#0000FF',
            fill: false
          }, {
            label: 'Bad Rest',
            data: quadraticData[1],
            borderColor: '#0080FF',
            fill: false
          }, {
            label: 'Moderate Rest',
            data: quadraticData[2],
            borderColor: '#4682B4',
            fill: false
          }, {
            label: 'Good Rest',
            data: quadraticData[3],
            borderColor: '#5F9EA0',
            fill: false
          }]
        },
        options: {
          scales: {
            x: {
              type: 'linear',
              position: 'bottom',
              title: { display: true, text: 'Relative second grade', },
              min: -8, // Set the minimum x-value
              max: 8  // Set the maximum x-value
            },
            y: {
              type: 'linear',
              position: 'left',
              title: { display: true, text: 'Relative result grade', },
            }
          }
        }
      });
    }

    function solve(inputString) {
      gradeArray = inputString.split(" ");
      if (gradeArray.length === 3) {
        return addTwoEwbank(gradeArray[0], gradeArray[1], gradeArray[2]);
      } else if (gradeArray.length < 3) {
        return "Error";
      } else {
        // split
        startString = gradeArray[0] + " " + gradeArray[1] + " " + gradeArray[2];
        endString = inputString.slice(startString.length);
        newString = addTwoEwbank(gradeArray[0], gradeArray[1], gradeArray[2]) + endString;
        return solve(newString);
      }
    }

    function addTwoEwbank(start, rest, end) {
      start = Number(start);
      end = Number(end);
      if (!isNaN(start) && !isNaN(end)) {
        restValue = getRestValue(rest);
        //test basic conditions
        if (start <= (end - 8)) {
          return end;
        }
        if (end <= (start - 8)) {
          return start;
        }

        // Find a
        let a = ((4 - restValue) / 64)
        // Find b
        let b = 0.5;
        // Find c
        let c = start;
        console.log("a: " + a + " b: " + b + "c: " + c);
        // Find quadratic.
        let x = end - start;
        let ans = Math.round((a * x * x + b * x + c + restValue) * 100) / 100;
        if (ans < start) {
          return start;
        } else if (ans < end) {
          return end;
        } else {
          return ans;
        }
      } else {
        console.log("non number input: " + start + " or " + end);
        return "Error";
      }
    }

    function formatGradeString(inputString) {
      if (typeof inputString !== 'string') {
        return "Error";
      }
      if (!/[NBMGV]/i.test(inputString)) {
        return "Error";
      }

      const parts = inputString.toUpperCase().split(/[NBGM\s]+/).filter(Boolean); // Split by N, B, M, G, case-insensitive
      const separators = inputString.toUpperCase().match(/[NBGM]+/g).filter(Boolean) || []; // Extract separators

      let formattedString = "";
      let partIndex = 0;
      let separatorIndex = 0;
      // checks
      if (parts.length < 2 || parts.length === separators.length) {
        return "Error";
      }

      while (partIndex < parts.length) {
        let part = parts[partIndex].trim(); // Remove leading/trailing spaces
        if (part) {
          // deal with Vgrades 
          if (part.toUpperCase().startsWith("V")) {
            part = convertVgrade(part.toUpperCase(), !partIndex);
          }
          if (!isNaN(parseFloat(part))) {
            if (formattedString) { // Add space if it's not the first part
              formattedString += " ";
            }
            formattedString += parseFloat(part); // Ensure number is parsed as float
          } else {
            return "Error";
          }
        }

        if (separatorIndex < separators.length) {
          formattedString += " " + separators[separatorIndex];
          separatorIndex++;
        }
        partIndex++;
      }
      console.log(formattedString);
      return formattedString.trim(); // Remove trailing spaces
    }

    function convertVgrade(Vgrade, isAtStart) {
      // takes a Vgrade string "V6" and returns 26.3 (first) or 28 (second) 
      // https://www.desmos.com/calculator/a7n2mkrfw7
      let grade = Number(Vgrade.split("V")[1]);
      if (grade < 5) {
        grade += 20;
      } else if (grade > 7.5) {
        grade += 22;
      } else {
        grade = 1.5 * grade + 17.5;
      }
      //adjust for if at start of route or later.
      if (isAtStart) {
        grade -= 0.7;
      } else {
        grade += 1;
      }
      return grade;
    }

    function getRestValue(restType) {
      // take rest type and value from sliders
      restGaps = { "G": 0, "M": 1, "B": 2, "N": 3 };
      return Number(restGaps[restType] * (sliderN.value - sliderG.value) / 3) + Number(sliderG.value);
    }

    function translateGradeValue(gradeValue) {
      // take deciaml grade and output a string like [29 | 8a | 5.13a].Soft
      // or 29.soft
      let wholeGrade = Math.floor(gradeValue);
      let decimal = gradeValue - wholeGrade;
      console.log(gradeValue);
      updateGradeGraph(gradeValue);
      if (decimal > gradeUpperBounds.soft) {
        return (wholeGrade + 1);
      } else if (decimal <= gradeUpperBounds.middle) {
        return wholeGrade;
      } else if (decimal <= gradeUpperBounds.hard) {
        return wholeGrade + ".hard";
      } else if (decimal <= gradeUpperBounds.slash) {
        return wholeGrade + "/" + (wholeGrade + 1);
      } else {
        return (wholeGrade + 1) + ".soft";
      }
    }

    function updateGradeGraph(gradeValue) {
            const canvas = document.getElementById('gradeGraph');
            if (!canvas.getContext) {
                console.error("Canvas not supported.");
                return;
            }
            const ctx = canvas.getContext('2d');
            
            // --- Retina Fix: Get Device Pixel Ratio and calculate true dimensions ---
            const dpr = window.devicePixelRatio || 1;
            
            // --- Dynamic Width Calculation (Logical width) ---
            const resultContainer = document.getElementById('result');
            const LOGICAL_WIDTH = resultContainer ? resultContainer.clientWidth : 800;

            // Set canvas dimensions for sharpness: actual pixels = logical pixels * dpr
            canvas.width = LOGICAL_WIDTH * dpr;
            canvas.height = CANVAS_HEIGHT * dpr;
            canvas.style.width = LOGICAL_WIDTH + 'px'; // Set CSS size back to logical size
            canvas.style.height = CANVAS_HEIGHT + 'px';
            
            // Scale the context by the DPR, so all subsequent drawing coordinates are in logical pixels
            ctx.scale(dpr, dpr); 

            // Clear the canvas using logical dimensions
            ctx.clearRect(0, 0, LOGICAL_WIDTH, CANVAS_HEIGHT);

            // --- 1. Calculate Base Grade (N), Bar Range, and Relative Position (X) ---
            const N = Math.floor(gradeValue + 0.39999); 
            const N_minus_1 = N - 1;
            const N_plus_1 = N + 1;
            
            // Bar Range: N-0.6 to N+0.8 
            const N_START = N - 0.6; 
            const N_END = N + 0.8;   
            
            // Calculate normalized position X (0.0 to 1.0) relative to the start point N_START
            const X_NORM = (gradeValue - N_START) / TOTAL_SPAN; 

            // --- 2. Define Segments based on X-axis (0.0 to 1.0) ---
            // Normalized boundary positions (multipliers of 1/1.4):
            const NORM_0_2 = 0.2 / TOTAL_SPAN; // N-0.4
            const NORM_0_4 = 0.4 / TOTAL_SPAN; // N-0.2 (Start of main N segment)
            const NORM_0_6 = 0.6 / TOTAL_SPAN; // N.0 (Center of N-to-N+1 range)
            const NORM_0_8 = 0.8 / TOTAL_SPAN; // N+0.2 (End of main N segment)
            const NORM_1_0 = 1.0 / TOTAL_SPAN; // N+0.4
            const NORM_1_2 = 1.2 / TOTAL_SPAN; // N+0.6

            const segments = [
                // 1. Transition: N-0.6 to N-0.4 (0.2 units) - The (N-1)/N band
                { label: `${N_minus_1}/${N}`, startX: 0.0, endX: NORM_0_2, color: '#d1dce6', labelColor: '#4b5563'},
                // 2. Soft (N): N-0.4 to N-0.2 (0.2 units)
                { label: "soft", startX: NORM_0_2, endX: NORM_0_4, color: '#bbdefa', labelColor: '#4b5563'},
                // 3. N: N-0.2 to N+0.2 (0.4 units) - The main grade band
                { label: `${N}`, startX: NORM_0_4, endX: NORM_0_8, color: '#a6d3f7', labelColor: '#4b5563'},
                // 4. Hard (N): N+0.2 to N+0.4 (0.2 units)
                { label: "hard", startX: NORM_0_8, endX: NORM_1_0, color: '#86c5f7', labelColor: '#4b5563'},
                // 5. N/(N+1): N+0.4 to N+0.6 (0.2 units)
                { label: `${N}/${N_plus_1}`, startX: NORM_1_0, endX: NORM_1_2, color: '#d1dce6', labelColor: '#4b5563'},
                // 6. Soft (N+1): N+0.6 to N+0.8 (0.2 units)
                { label: "soft", startX: NORM_1_2, endX: 1.0, color: '#bbdefa', labelColor: '#4b5563'}
            ];

            // --- 3. Draw the Segments (Bar) ---
            ctx.strokeStyle = '#4b5563'; // gray-600
            ctx.lineWidth = 1;

            segments.forEach(segment => {
                const startPixel = segment.startX * LOGICAL_WIDTH;
                const width = (segment.endX - segment.startX) * LOGICAL_WIDTH;
                const centerX = startPixel + width / 2;

                // Draw the colored segment
                ctx.fillStyle = segment.color;
                ctx.fillRect(startPixel, BAR_Y, width, BAR_HEIGHT);

                // Draw the segment label text
                ctx.fillStyle = segment.labelColor;
                ctx.font = 'bold 16px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(segment.label, centerX, BAR_Y + BAR_HEIGHT / 2);

                // Draw segment boundary lines
                ctx.strokeStyle = '#4b5563';
                ctx.strokeRect(startPixel, BAR_Y, width, BAR_HEIGHT);
            });

            // --- 4. Draw the Major Tick Marks (Boundaries and Integer N) ---
            ctx.fillStyle = '#1f2937'; // gray-800
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            // Function to draw tick mark and label
            const drawTick = (normalizedX, gradeOffset) => {
                let pixelX = normalizedX * LOGICAL_WIDTH;
                // Display the precise decimal boundary value (e.g., 7.0)
                let gradeLabel = (N_START + gradeOffset).toFixed(1);
                let textAlign = 'center';
                
                // Adjust alignment for edges to prevent clipping
                if (normalizedX < 0.01) {
                    textAlign = 'left';
                    pixelX += 2; // slight shift right
                } else if (normalizedX > 0.99) {
                    textAlign = 'right';
                    pixelX -= 2; // slight shift left
                }
                
                // All ticks are standard size and placed below the bar
                ctx.font = 'bold 16px Inter';
                ctx.textAlign = textAlign;
                
                let yPos = BAR_Y + BAR_HEIGHT + 10;
                
                ctx.fillText(gradeLabel, pixelX, yPos);
            };

            // Boundary Ticks
            drawTick(0.0, 0.0); // N-0.6
            drawTick(NORM_0_2, 0.2); // N-0.4
            drawTick(NORM_0_4, 0.4); // N-0.2
            drawTick(NORM_0_6, 0.6); 
            drawTick(NORM_0_8, 0.8); // N+0.2
            drawTick(NORM_1_0, 1.0); // N+0.4
            drawTick(NORM_1_2, 1.2); // N+0.6
            drawTick(1.0, 1.4); // N+0.8


            // --- 5. Draw the Vertical Marker for gradeValue ---

            // Calculate the pixel position of the actual gradeValue using X_NORM
            const markerX = X_NORM * LOGICAL_WIDTH;

            // Draw the vertical line marker
            ctx.beginPath();
            ctx.strokeStyle = '#000000'; // Black line
            ctx.lineWidth = 3;
            ctx.moveTo(markerX, BAR_Y - 10); // Start slightly above the bar
            ctx.lineTo(markerX, BAR_Y + BAR_HEIGHT + 10); // End slightly below the bar
            ctx.stroke();
            ctx.closePath();

            // Draw the label for the gradeValue
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 20px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';

            // Determine label position to avoid clipping
            let labelX = markerX;
            // Adjust if too close to the left edge
            if (markerX < 50) {
                ctx.textAlign = 'left';
                labelX = markerX + 5;
            }
            // Adjust if too close to the right edge
            else if (markerX > LOGICAL_WIDTH - 50) {
                ctx.textAlign = 'right';
                labelX = markerX - 5;
            } else {
                ctx.textAlign = 'center';
            }


            // Draw the grade label above the bar
            ctx.fillText(`${gradeValue.toFixed(2)}`, labelX, BAR_Y - 10);

            // Draw a small circle at the base of the marker for visual emphasis
            ctx.beginPath();
            ctx.arc(markerX, BAR_Y + BAR_HEIGHT, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#000000';
            ctx.fill();
            ctx.closePath();
        }


    function updateClimbList() {
      // Clear existing list items before adding new ones
      while (climbListUL.firstChild) {
        climbListUL.removeChild(climbListUL.firstChild);
      }

      // Loop through the climb list and add items to the list
      ewbankClimbList.forEach(function (climb, index) {
        // Create the input field
        let nameInput = document.createElement("input");
        nameInput.type = "text";
        nameInput.value = climb.name || ""; // Use climb.name or an empty string
        nameInput.classList.add("listName");

        let listItem = document.createElement("li");
        let climbText = document.createTextNode(" " + climb.climbString + " = " + climb.grade + " [" + climb.sliderG + ".." + climb.sliderN + "]");
        // Create the copy to inpiut button
        let copyButton = document.createElement("button");
        copyButton.textContent = "<";
        copyButton.value = climb.climbString + "|" + climb.sliderN + "|" + climb.sliderG;
        copyButton.addEventListener("click", function (event) {
          const button = event.target;
          let climb = button.value.split("|");
          climbString.value = climb[0];
          sliderN.value = climb[1];
          sliderG.value = climb[2];
          sliderOutputG.textContent = "Good rest change: " + sliderG.value;
          sliderOutputN.textContent = "No rest change: " + sliderN.value;
          gradeIt();
          graphIt();
        });
        // Create the delete button
        let deleteButton = document.createElement("button");
        deleteButton.textContent = "X";
        deleteButton.className = "delete";
        deleteButton.addEventListener("click", function () {
          console.log("deleting: ", ewbankClimbList[index]);
          ewbankClimbList.splice(index, 1); // Remove the item from the array
          localStorage.setItem("ewbankClimbList", JSON.stringify(ewbankClimbList)); // Update local storage
          updateClimbList(); // Re-render the list
        });
        listItem.appendChild(copyButton);
        listItem.appendChild(nameInput);
        listItem.appendChild(climbText);
        listItem.appendChild(deleteButton);
        climbListUL.appendChild(listItem);

        // Add the listener for tab out (blur event)
        nameInput.addEventListener("blur", function () {
          // Update the climb object in the array
          ewbankClimbList[index].name = nameInput.value;
          // Update local storage with the modified array
          localStorage.setItem("ewbankClimbList", JSON.stringify(ewbankClimbList));
        });
      });
    }

    /**************************************
      On Load Event
    **************************************/
    document.addEventListener("DOMContentLoaded", function () {
      // check url for data
      const urlParams = new URLSearchParams(window.location.search);
      const encodedClimbs = urlParams.get('data');
      const urlN = urlParams.get('sliderN');
      const urlG = urlParams.get('sliderG');
      if (encodedClimbs) {
        try {
          const climbFromURL = JSON.parse(atob(encodedClimbs)); // Base64 decode
          climbString.value = climbFromURL;
          if (urlN) {
            sliderN.value = urlN;
            sliderOutputN.textContent = "No rest change: " + sliderN.value;
          }
          if (urlG) {
            sliderG.value = urlG;
            sliderOutputG.textContent = "Good rest change: " + sliderG.value;
          }
          gradeIt();
        } catch (error) {
          console.error("Invalid URL parameters:", error);
        }
      }
      // initial climb beanchmarks
      let beanchmarks = [
        {
          'climbString': '32 G V13 B 35 G 27',
          'grade': 37.95,
          'name': "Bibliographie 9b+",
          'sliderG': "1.75",
          'sliderN': "2.5",
        },
        {
          'climbString': '27 N V9.5 M 27',
          'grade': 33.09,
          'name': "Le Minimum 8c",
          'sliderG': "1.75",
          'sliderN': "2.5",
        },
        {
          'climbString': '28 N V5 N V7 M 25',
          'grade': 31.85,
          'name': "Centripetal Force 32",
          'sliderG': "1.75",
          'sliderN': "2.5",
        },
        {
          'climbString': '25 N V10 G 27',
          'grade': 33.02,
          'name': "Paint it Black 33",
          'sliderG': "1.75",
          'sliderN': "2.5",
        },
        {
          'climbString': '22 N 27 N 24 G V7 N V4 B V5 M 27',
          'grade': 32.4,
          'name': "Kaz's Project",
          'sliderG': "1.8",
          'sliderN': "3",
        },
        {
          'climbString': 'V7 N 26 M 25 N V6',
          'grade': 31.2,
          'name': "Godspeed",
          'sliderG': "1.75",
          'sliderN': "2.5",
        },
        {
          'climbString': '35 B 29 B V10 M V11 M 29',
          'grade': 38.07,
          'name': "The End Is the Beginning Is the End",
          'sliderG': "2",
          'sliderN': "3",
        },
        {
          'climbString': '24 B 22 M 24',
          'grade': 27.08,
          'name': "Bolt Chaser",
          'sliderG': "1.75",
          'sliderN': "3",
        }
      ];
      // Retrieve the climb list from local storage
      ewbankClimbList = JSON.parse(localStorage.getItem("ewbankClimbList")) || beanchmarks;
      updateClimbList();
      graphIt()
    });
  </script>